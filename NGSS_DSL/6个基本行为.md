

#CRUD 和 connect disconnect 是6个基本的行为


以下用 En (n=1,2..) 代表一个Entity，Rn 代表一个关系, attrn 代表任意一个contains的属性

##1. create
###用法：create E
	
###说明：
这一句的结果是持久化了一个E的实例。结果是E。
例如E.uuid是系统持久化时自动生成的，那么在后面使用这个uuid时，就可以这么写
...
create E1
connect E2.attr1，E1.uuid (关于connect的写法后面讨论，这里仅表示某个关系中需要E1.uuid)
注意这里仅持久化，并不是说在内存里创建一个对象。
这个操作还包括了E实例的有效性的校验。包括E中每个字段的有效性校验和E中定义的字段间的有效性校验。
		

###上下文分析：
create 行为没有其他参数，因此它的唯一操作对象就是当前上下文中，类型是E的实例。
因此，E的所有成员数据，都应该在create E之前准备好。
		
create E 的行为一定发生在某个关系的某个行为定义中。所以这个上下文中比较明确的信息有：
####1. 前提假设
	假设一个关系R的声明是 R(role1, role2, role3)
	假设当前行为是 roleX 的 behavior1
####2. 上下文中的类型
	关系名称是R
	role1，role2, role3的类型，他们就是关系R实例中，对应role1..n的Entity的类型。
		举个例子，关系声明是 R(role1, role2, role3), 假设有两处使用了这个关系，分别为“E1 R E2,E3” 和 "E4 R E5,E6"
		那么create语句的上下文中，是可以知道，在第一个R实例中，role1/2/3的类型分别是E1/2/3, 第二个实例中role1/2/3的类型是E4/5/6
		那么 create role3 （在R的行为定义中）就等价于 create E3 和 create E6
####3. 上下文中的实例
	关系的实例就是当前关系实例，这个没有疑问
	实体的实例就是当前关系实例中指向的每个角色的实例
	上面说过”假设当前行为是 roleX 的 behavior1“， 那么 create roleX 可以简写为 create。
	对于两两关系，create $from 和 create $to 是否可以简写为create , 要看当前行为的责任者是否和要create的目标一致。假设通过某种方式可
	以推断当前责任者是$from, 而且现在想做的事情就是持久化$from， 那就可以简写为create
	
	结果：
		1. create 成功，结果是当前实例。 例如 create role2 的结果就是 role2， 后面的语句中就可以直接使用role2来表示create的结果
		2. 参数校验失败，当前实例不变，if(error()) 结果为true， if (exception()) 结果为false
		3. DB操作失败，当前实例不变，if(exception())结果为true，if (error()) 结果为false
		注：if(error()) if (exception()) 是条件表达式。是否这么表达待定。这里仅表示 error 和 exception 是两种不同的错误类型
		
	附：错误信息和异常信息该如何表示？我设想的是不用 error() 而用$error. 然后有一个 $error.message 和 $error.params, 由生成的代码负责填写。
		$error.message 是一个MessageKey，格式就是类似“Parameter invalid: name=${name},sex=${sex}"这种，用E的属性名字做key，放在${}里面。
		这个是系统自动生成的错误信息，默认不修改的话，前台可以看到E的所有有值的属性。假设将来要改变显示的信息，客户可以拿$error来自己写。
		exception和error类似。
		
##2. read
###用法：
read E
read E,E1,E2,E3...
或者
search E
search E,E1,E2,E3
		
###说明：
	从数据持久层里找到E。 如果是第二种写法，就是从数据持久层里，根据E1,E2...的情况找到符合条件的E
	这个分析怎么做比较麻烦，不过定义它就是个search操作还是比较明确的。 如何根据E1,E2...来找E的事情后面再说。先说简单的。
	只有一句 read E 的意思是，根据E的唯一性标识来找E。
	在定义E的时候，应该有关系 identifiedBy 和 definedBy 关系，那么生成的代码里，会先找ID，后找唯一性字段。
	举个例子：假设E的定义是这样
		E {
			identifiedBy E1
			definedBy E2,E3
			containsMany E4
			xxxRelation Ex
		}
	那么read E就会有类似如下伪代码生成：
		{
			if (validE1(E))
				return EManager.readByE1(E);
			if (validE2(E) && validE3(E))
				return EManager.readByE2E3(E);
			return null
		}
		
###上下文分析：
		参考Create的上下文分析，我们可以得到当前的关系类型和实例，当前关系的参与各方的类型和实例，当前行为的责任者的类型和实例。
		read roleX 同样可以简化为read, 意思是根据id或者特征字段读取唯一的一个‘当前行为责任者’的实例.
		
		// 附注：除此之外，我们还可以有一个东西从上下文里推导出来：当前操作的目标。
		// 举个例子：假设现在我们在$from的某个行为里create $to, 代码看起来如下：
		// 	$from.behaviorX {
		// 		create $to
		// 		read
		// 	}
		// 此时我们是否应该假设要read $to呢？ 还是避免歧义，直接写 read $to?
		
###结果：
		read E 的结果是Null 或者一个 E 的实例。 E 可以在后续操作中作为一个标识符使用。
			所以这个操作的‘潜规则’是，把当前关系中的参与者E，替换成搜索的结果。 （貌似有些不合理吧？需讨论。）
		
		read E，E1,..的结果是List<E>。 结果标识符是不是还是E，这个情况稍微复杂一点。
		case1：List<E> 有歧义
			假设关系R中E是一个参与者，那么在整个行为定义中，标识符"E"指的是关系中E类型的参与者，而不是read E,...的结果。
			如果参与者是一个实例，搜索结果是集合，而且后面要使用搜索结果，那么必须使用局部变量类似 list=read E,...
		case2：List<E> 无歧义
			假设E是关系的一个间接参与者，而且在当前行为中，仅在此处开始，那么后面就很明确是使用List，没有歧义。
			此时使用局部变量仍然可以工作
		所以建议都使用局部变量
		
		错误：read 方法没有 error, 只有exception
		
##3. update
###用法：
update E
update E, E1,E2,...
###说明：
	update E 表示把当前E实例的更改持久化到数据库
	update E, E1,E2... 表示根据E1,E2...的值，更新E的对应字段，然后持久化到数据库
	这里仍然要做参数校验。
	与create不同的地方在于，update E，E1,E2...的校验实现方式如果是先拷贝新值，然后再校验，那么校验失败后内存实例被污染了。
	所以得到一个推论：verifyXXX方法的参数应该是各个参数，而不是整体的E。 这个细节后面再讨论。
	如何解决‘表示根据E1,E2...的值，更新E的对应字段’思路和search类似，以后专门讨论
###上下文分析：
	同上，还是知道当前的关系和所有参与者的类型及实例
	update roleX 还是可以简写为 update
###结果：
	成功的结果标识符还是E
	error为真（不为空）表示参数校验出了错误
	exception表示系统异常，系统应该自动保证内存变量也被‘回滚’。所以update的实现方式有待考虑。

##4. delete
###用法：delete E
###说明：从持久化层删除E
	持久化层删除E，内存中的E应该还存在，直到退出当前行为。
###上下文分析：
	同上。 delete roleX 可以简写为delete
###结果：
	成功的结果标识符还是E。
	删除有两种失败：
	一种是业务逻辑限制，不能删除，此时报error貌似比较合理。但是我们假设delete行为仅仅是数据操作，所以这种情况应该在前面的行为条件中判断，所以不存在。
	第二种是数据库操作失败。应该报exception. 包括外键约束失败也应该是业务没做好导致的，所以是不期望发生的，所以放在exception里也合理。
	所以失败就只有exception，没有error
		
##5. connect
###用法 connect R1(E1,E2...) 
		简写可以是
		 connect R1()
		 connect (E1,E2...)
		 connect
###说明
		先说connect的目标都是复合实体的情况。
		connect的正式含义是：触发指定角色之间的，指定关系的‘建立关系’操作。
		为实体 E1,E2... 建立关系R1，其中E1,E2...承担的角色与R1定义中的角色顺序一致。
		简写的原则是： 
		case1: 如果不写E1,E2...就表示使用当前关系实例的所有参与者，顺序和当前关系定义一致
		case2: 如果不写R1,并且参与者可推断为当前关系的参与者，则表示建立当前关系的实例
		case3: 如果不写R1,并且参与者无法确定是否为当前关系的参与者，并且满足‘角色定义’的关系只有一个，则建立此关系
		case4: 以上都不是，则建立自然关系
		举个例子：
		假设当前关系的定义是 R1(E1,E2),同时系统存在关系定义R2(E1,E2), R3(E2,E3)
		case1：假设在关系定义R1,行为 $from.behaviorX 中有“connect R2()”, 则等价于 connect R2(E1,E2)
		case2: 假设在关系定义R1,行为 $from.behaviorX 中有“connect”, 则等价于 "connect (E1,E2)"且等价于connect R2(E1,E2)
		case3: 假设在关系定义R1,行为 $from.behaviorX 中有“connect (E2,E3)” 则系统遍历所有满足“Rx(E2,E3)”的关系实例，最后确定Rx=R3
		case4：假设有connect (E3,E4), 因为找不到任何满足形为“Rx(E3,E4)”的关系，所以可能产生结果是 E3.setE4(E4) 的行为

		connect 的写法应该有几个变种，（考虑下是否容易解析）

		假设 R 定义了connect 的动作 $from-->connect-->$to 为 “do_something”,
		那么 E1 do_something E2 应该和 connect (E1,E2) R 等价
		同理 do_something 这种简写 也应该和 connect ($from, $to) R 等价
		假设 R 定义了connect 的动作 $to-->connect-->$from 为 “be_done_something”
		那么 E2 be_done_something E1 应该和 connect (E1,E2) R 等价
		这里的问题是如何确定变种的名字是属于哪个关系的。
		一种思路是‘搜索’：第一个token如果不是任何关键字，那他就是一个实体，第二个token就是变种，后面的都是参与的实体。 
			因此搜索第一个实体参与的所有关系，找到满足符合‘角色定义’的关系，再从定义中搜索匹配的名字。
		另外一种思路是‘上下文’。 缺省的‘变种名字’都是当前关系的。
		第三种思路是假设关系名，写成：E1 R.do_something E2
		第一种思路会cover第二种
		第三种方便分析
		
		现在说connect的对象是边界对象的情况。
		connect的正式含义是：触发指定角色之间的，指定关系的‘建立关系’操作。
		如果对象是边界对象，那么建立关系的方式，如果没有在关系中特别声明的话，那么就是建立‘自然关系’
		connect的自然关系和类型有关，产生的代码形式如下：
			$from,$to=String,String: 	$from = $to
			$from,$to=Number,Number: 	$from = $to
			$from,$to=Enum,Enum: 		$from = $to
			$from,$to=Enum,String: 		$from = Enum.fromValue($to)
			// from value 是我们自动创建的，从字符串转为Enum的方法
			$from,$to=String,Enum: 		$from = $to.toString()
			$from,$to=String,Number: 	$from = $to.toString()
			$from,$to=Number,String: 	$from = $to.toNumber()		
			// toNumber 是个表示方式。实际的代码和$from的Number类型有关，可能会异常
			$from,$to=String/Number/Enum, Entity: $to.set$From($from)
			$from,$to=Entity, String/Number/Enum: $from.set$To($to)
			$from,$to=Entity,Entity: 	$from.set$To($to)
				
###上下文分析：
connect的上下文和前面相同。
不过由于connect 至少需要两个操作数，所以roleX这样的‘当前行为负责人’就没有什么用了。
		
###结果：
成功建立连接的结果没有特定的标识符，如果不用临时变量指代的话，后面想根据连接建立是否成功判断，只有使用connect语句本身
例如有代码{
		try{
			connect E1,E2
			if (error()) {
				connect E1,default_E2	// 假设default_E2已经定义
			}
			connect E3,E4
			if (error()) {
				// 什么都不做，没成功就算了。 所以这段其实可以不写
			}
		}
		if (exception(connect E1,E2) || exception(connect E1,default_E2))
			do something
			return false	// 如果connect E1,E2 异常，事务失败
		if (exception(connect E3,E4))
			do something others
			return true		// 如果connect E3，E4有异常，只是发发通知什么的，事务还算成功
	}
	error表示校验失败
	exception表示系统错误。
	
	##6. disconnect
		disconnect的大多数说明和connect一样，唯一的区别在于‘断开自然关系的定义’：
		$from,$to=String,String: 	报错
		$from,$to=Number,Number: 	$from = $from - $to
		$from,$to=Enum,Enum: 		报错
		$from,$to=Enum,String: 		报错
		$from,$to=String,Enum: 		报错
		$from,$to=String,Number: 	报错
		$from,$to=Number,String: 	$from = $from - $to.toNumber()		
		// toNumber 是个表示方式。实际的代码和$from的Number类型有关。可能会异常
		$from,$to=String/Number/Enum, Entity: $to.set$From(null)
		$from,$to=Entity, String/Number/Enum: $from.set$To(null)
		$from,$to=Entity,Entity: 	$from.set$To(null)
