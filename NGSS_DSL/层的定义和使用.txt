层，可以理解就是包，名字空间。

层的目的
	层的目的是明确上下文，限定业务场景，从而使实体和关系的名字具备确定的意义。
层的形式
	层是一个字符串。
	这个字符串可以是a.b.c这种点分格式的，也可以是001xxx,002xxx这种格式的。 总之，它就是一个字符串。
	在不涉及‘自动推衍’的情况下，只有层的全名才具备意义，所以不关心格式。
	如果希望利用层的名字进行辅助推导，那么点分格式容易构成树状结构，使用起来更灵活。
层的引用
	层的作用是限定范围，引用的方式参照Java的包名规则。
	规则1：语义网定义中，必须首先声明所在层
		例如，一个语义网定义文件的第一行，应该是类似Java Package声明的语句。 我们不支持default层。
		Java的包名是和文件路径有对应关系的。我们假设语义网定义和关系规格定义不一定存储在文件系统中，或许是个网络流。所以如何获得定义文件有另外的概念来支撑，这里仅说明一点：定义文件中会显式的声明自己的层名。
	规则2：同层之间引用不需要显式指明层
		例如，两个实体 E1，E2， 存在关系 E1 mustContainsMany E2 时，由于E1，E2 
	规则3：系统缺省的层，不需要显式引用
		层是‘上下文’。相同缺省层就是类似‘地球人都知道’的情况，层名类似“system”。
	规则4：引用其他层，必须显式的引用
		和Java的import语句一样
	规则5：实体的层命名空间，和关系的层命名空间无关。
		主要是关系和实体的划分方式不同。 
		关系的层结构，和实体的层结构应该是正交的。因为他们划分的维度互不相关。实体按照业务划分，关系按照行为特征划分。
	规则6：层定位的顺序是先特殊后一般，同优先级的层中不能有冲突。
		这个很好理解，越具体的越优先。 具体来说，搜索顺序是：
		如果指定了层名：指定层-->找不到就报错
		如果未指定层名：当前层-->系统缺省层-->间接引用的层-->所有可搜索路径上发现的其他层-->找不到报错
		
		假设我们带定义中使用了诸如“From R X”这样的语句要引用实体X（不带层名的应用），
		例如有层 A，引用了层B，B引用了C，同时这个目录下还有很多其他层定义文件：D,E,F
			1-假设实体X在A中有定义，那么X就等价于 A.X
			2-否则就尝试使用 system.X
			3-还找不到试图查找 B.X和C.X。 如果B.X和C.X只有一个存在，那么就使用 B.X/C.X 替换X；如果两个都存在，则无法确定，报错。（注意这里尽管B离A比C离A更近，但是他们都是‘间接引用’，优先级相同。 或者说，反正都是猜的，没谁比谁更高贵，所以发现冲突就报错）
			4-如果B,C都没有X，那么就找D.X,E.X,F.X。 冲突的话要报错。 （此步待定）
			5-还找不到则报告找不到
	规则7：层名和实体/关系名的分割符为双冒号。
		这个规则应该很少会被用到。以防万一。点号很多地方都在用。实体的Path应该会用点号，这样的话，拿到一个a.b.c.d.e的长表达式，就无法分别哪个是层名，哪个是起点实体
使用层的场景
	在语义网定义文件中（实体定义）
	在关系的规格文件中